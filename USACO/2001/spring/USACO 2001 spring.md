Green
=====

PROBLEM 1: Cowfix
---------

记忆化搜索。设dp\[i\]\[j\]表示字符串i..j计算后所能得到的方案(dp\[\]\[\]储存的是方案的集合)。<br/>
显然：这里的opt为操作符(+或-)，并且是集合内每个元素的操作<br/>
1.dp\[i\]\[j\]=dp\[i\]\[k\] opt dp\[k+1\]\[j\]，如果str\[k\]为操作符，这时候是计算中缀表达式<br/>
2.dp\[i\]\[j\]=dp\[i+1\]\[k\] opt dp\[k+1\]\[j\]，如果str\[i\]为操作符，这时候是计算后缀表达式<br/>
2.dp\[i\]\[j\]=dp\[i\]\[k\] opt dp\[k+1\]\[j-1\]，如果str\[j\]为操作符，这时候是计算前缀表达式<br/>
最后统计dp\[1\]\[n\]元素个数即可

PROBLEM 2: Cattle Spotting
------------
注意到点的总数不大，我们可以通过暴力枚举矩形的左上角进行判断，不过仅仅左上角会漏解，我们还需要再次枚举左下角进行计算。

PROBLEM 3: The Milk Route
-------------
计算几何+floyd+dp<br/>
首先们预处理出，任意两个奶牛之间的概率，中间需要进行线段相交判断<br/>
然后对于任意两个奶牛，有时候通过其他奶牛当中间点可能会使概率增加，于是我们通过floyd算法计算出任意两个奶牛之间的最大概率，存为map\[\]\[\]<br/>
接下来我们分阶段dp就可以了，设dp\[k\]\[i\]表示从Barn经过k个奶牛(包括i)后到达i的最大概率，dp\[k\]\[i\]=max{dp\[k-1\]\[j\]*ma\p[j\]\[i\]} j!=i<br/>
最后枚举i和j，计算max{dp\[i\]\[j\]*dp\[k-i+1\]\[j\]}就是答案<br/>
需要注意的是在计算叉积时临时结果会超过int，我们需要用double转存.

PROBLEM 4: Traveling Cows
---------------
赤裸裸的网络流模型。<br/>
将每个点i拆成i和i'，对于每一条无向边(i,j)添加边(i',j)和(j',i)，容量均为∞。然后添加边(i,i')容量为1，如果i=1或2，容量改为∞。以1为源，2’为汇做一次最大流就行了。



Orange
=====

PROBLEM 5: Krunch
-------

PROBLEM 6: Square Designs
-------------

PROBLEM 7: Runaround Numbers
------------

PROBLEM 8: Score Inflation
-------------

PROBLEM 9: Ice Cream
-------------


