这次的题目比昨天的简单了许多，代码复杂度比昨天降低了许多，难怪时限是4 hours。
这次题目貌似还是TC原题，官方题解就自己去用google慢慢找吧。

Problem A Grabbing Taxi
floyd算法
我们这里假设目标点也是出租车停靠点，然后将(0,0)和每一个出租车停靠点连一条边，长度为(|tXs[i]|+|tYs[i]|)*walkTime；接下来每两辆出租车之间连一条边，长度为(|tXs[i]-tXs[j]|+|tYs[i]-tYs[j]|)*min(taxiTime,walkTime)。最后一边floyd就搞定了。

Problem B Strong Prime Power
数学题
我们知道n=p^q，并且q>=2，n<=10^18，那么显然q最大只是59（2^59<10^18, 2^60>10^18），也就是说q很小。
然后我们枚举q，根据p=\sqrt[q]{n}，求出p，判断一下p是不是素数，然后暴力判断p^q是否等于n就可以了。
注意求p的时候不能截断取整，用p=floor(\sqrt[q]{n}+0.5)就行。

Problem C Lighted Panels
枚举+位运算加速(貌似不用位运算也是可以的)
这道题目估计是这次比赛中最难的吧，不过我在寒假的时候做过叉姐（你问叉姐是谁？叉姐就是交大某位神牛。）的一道类似的题目，感觉上也不是特别难。
首先我们可以知道，每个位置最多摸一次（多摸是没有意义的），然后每个位置摸的先后顺序是没有区别的，于是我们就可以加一个限制条件：每次只能从左往右，从下往上摸，同时我们先不考虑第0列和第0行是不是要摸。
经过这样限制后，我们可以很容易判断位置(i,j)是否要摸。如果(i-1,j-1)位置是0，那么(i,j)就要摸，否则不用。也就是说，如果我们确定了第0列和第0行light的状态，我们可以通过递推求出所有的位置是否要摸。
到这里，算法就比较明晰了。
1.枚举第0列和第0行的状态(这样说可能不容易懂，其实是枚举第0列和第0行每一个位置是否需要摸)，最大也就是2^15=32768种状态吧。
2.利用递推算出每个位置是否要摸，所有要摸的位置个数总和就是步数step。
3.取所有step的最小值就是答案。
貌似还没有考虑无解的情况，这个其实是最简单的，在第2步的最后，如果最终的board还有灯关着，那么这个step就无效。如果所有step都无效，那么就是无解。
那啥时间复杂读貌似是O(2^(N+M-1)*NM)

Problem D Dreaming About Carrots
这道题目就不用说了，各种方法随便用都可以AC。

Problem E FIELD Dia
简单计数dp
设dp[i][j]表示第i行有j个boxes的方案数，dp[i][j]=∑dp[i-1][k] (0<=j<=n-i-1, j<=k<=n-i+2)
最终答案是∑dp[n][i]

Problem F Word Abbreviation
暴力枚举吧。

Problem G Consecutive Numbers
模拟题。根据题目的意思乱做就可以了。

Problem H Random Sort
概率dp。
设dp[P]表示当前排列为P的期望值，P'表示将排列P交换任意一对逆序对之后的排列，然后根据高中所学的期望的知识，dp[P]=(∑dp[P'])/sum+1，其中sum表示P中逆序对的个数。还需要注意一点，如果sum=0，那么这个dp[P]=0。实现的话，用记忆化搜索比较简单。
至于P怎样用int值来表示，貌似方法很多，我是用康托展开来解决的，用STL中的map貌似更加简便。


